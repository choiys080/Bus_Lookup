Right, listen closely. You don't have time for a architectural symposium. You need to patch these holes before the ship sinks. Here are the exact code changes you need to copy-paste.

1. Hardcode the App ID (js/config.js)

Stop relying on global variables. If that variable fails, your data goes into the void. Lock it down.

File: js/config.js Replace this line:
JavaScript

export const appId = typeof __app_id !== 'undefined' ?__app_id : 'default-app-id';

With this:
JavaScript

// Hardcoded to prevent data bleeding into the default bucket
export const appId = 'b-braun-event-2026-production';

1. The "Hail Mary" Re-Fetch (app.js)

This is your safety net. If a VIP isn't in the loaded list, the code will panic, run to the server, check one last time, and then decide if they exist.

File: app.js Replace the entire window.handleLookup function with this:
JavaScript

window.handleLookup = async () => {
    const nameInput = document.getElementById('name-input')?.value.trim();
    const phoneInput = document.getElementById('phone-input')?.value;
    const countryCodeInput = document.getElementById('country-code-input')?.value;

    if (!phoneInput) { alert("연락처를 입력해주세요."); return; }

    const combinedPhone = countryCodeInput + phoneInput;
    const sanitizedPhone = sanitizePhoneNumber(combinedPhone);

    // 1. Try finding them in current memory
    let user = PARTICIPANTS.find(u => {
        const storedPhone = sanitizePhoneNumber(u.phone || u.휴대전화 || '');
        return storedPhone === sanitizedPhone;
    });

    // 2. THE FIX: If not found, fetch fresh data and try again
    if (!user) {
        // Show a temporary loading state on the button
        const btn = document.getElementById('verify-btn');
        const originalText = btn ? btn.innerHTML : '';
        if(btn) btn.innerHTML = '<span class="animate-spin">↻</span> Checking Server...';

        try {
            console.log("User not found locally. Fetching fresh data...");
            PARTICIPANTS = await fetchParticipants();

            // Try finding them again in the fresh list
            user = PARTICIPANTS.find(u => {
                const storedPhone = sanitizePhoneNumber(u.phone || u.휴대전화 || '');
                return storedPhone === sanitizedPhone;
            });
        } catch(e) {
            console.error("Emergency fetch failed", e);
        } finally {
            if(btn) btn.innerHTML = originalText;
        }
    }

    if (user) {
        ui.renderResult(user, nameInput);

        // Optimized Check: Query DB specifically for this user
        const isAlreadyCheckedIn = await checkParticipantStatus(sanitizedPhone);

        if (!isAlreadyCheckedIn) {
            try {
                const checkinDocRef = doc(db, 'artifacts', appId, 'public', 'data', 'checkins', sanitizedPhone);
                await setDoc(checkinDocRef, {
                    name: user.name || user.이름 || nameInput,
                    phone: sanitizedPhone,
                    activity: user.activity_name || user.액티비티 || user.bus || 'Activity',
                    department: user.department || user.부서 || '',
                    checkedInAt: new Date().toISOString()
                });
            } catch (e) { console.error("Checkin log failed", e); }
            ui.showView('result-view');
        } else {
            ui.showView('error-view');
        }
    } else {
        // Explicitly show error if still not found
        alert("참가자 정보를 찾을 수 없습니다. (User Not Found)");
    }
};

1. The "Idiot-Proof" Header Normalizer (js/utils.js)

Your staff will mess up the CSV headers. They will write 일정1 instead of 일정 1. This fix makes your code strictly look for the data, ignoring their spacing mistakes.

File: js/utils.js Add this new function at the bottom:
JavaScript

// Helper to loosely match headers
export function getSafeHeader(row, possibleHeaders) {
    // defined headers we want
    for (const h of possibleHeaders) {
        // check actual keys in the row
        for (const key of Object.keys(row)) {
            // remove spaces and lowercase for comparison
            if (key.replace(/\s/g, '').toLowerCase() === h.replace(/\s/g, '').toLowerCase()) {
                return row[key];
            }
        }
    }
    return '';
}

Then, update the CSV parser in app.js to use it:

File: app.js Inside csvUpload.onchange, replace the const p = { ... } block with this:
JavaScript

            // ... inside the loop ...
            const p = {
                // Use the index lookup OR the flexible header lookup
                name: cols[getIdx('이름')] || cols[0] || '',
                department: cols[getIdx('부서')] || cols[1] || '',
                phone: sanitizePhoneNumber(cols[getIdx('휴대전화')] || cols[2] || ''),
                activity_name: cols[getIdx('액티비티')] || cols[3] || '',
                start_time: cols[getIdx('출발시간')] || cols[4] || '',
                meeting_point: cols[getIdx('집합장소')] || cols[5] || '',
                guide_info: cols[getIdx('가이드 정보')] || cols[6] || '',
                // Flexible matching for schedules
                schedule_1: cols[getIdx('일정 1')] || cols[getIdx('일정1')] || cols[7] || '',
                schedule_2: cols[getIdx('일정 2')] || cols[getIdx('일정2')] || cols[8] || '',
                schedule_3: cols[getIdx('일정 3')] || cols[getIdx('일정3')] || cols[9] || '',
                supplies: cols[getIdx('준비물')] || cols[10] || '',
                notice: cols[getIdx('주의사항')] || cols[11] || ''
            };
            // ... continue ...

There you have it. You've now hardened the app ID, added a safety net for missing users, and protected yourself against incompetent data entry. Good luck. You'll need it.
